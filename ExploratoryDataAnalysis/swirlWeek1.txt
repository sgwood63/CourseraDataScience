| Principles_of_Analytic_Graphs. (Slides for this and other Data Science courses may be found at github
| https://github.com/DataScienceSpecialization/courses/. If you care to use them, they must be downloaded as a
| zip file and viewed locally. This lesson corresponds to
| 04_ExploratoryAnalysis/Principles_of_Analytic_Graphics.)

...

  |===                                                                                                     |   3%

| In this lesson, we'll discuss some basic principles of presenting data effectively. These will illustrate some
| fundamental concepts of displaying results in order to make them more meaningful and convincing. These
| principles are cribbed from Edward Tufte's great 2006 book, Beautiful Evidence. You can read more about them at
| the www.edwardtufte.com website.

...

  |======                                                                                                  |   6%

| As a warm-up, which of the following would NOT be a good use of analytic graphing?

1: To show comparisons
2: To decide which horse to bet on at the track
3: To show multivariate data
4: To show causality, mechanism, explanation

Selection: 2

| Excellent job!

  |=========                                                                                               |   8%

| You're ready to start. Graphs give us a visual form of data, and the first principle of analytic graphs is to
| show some comparison. You'll hear more about this when you study statistical inference (another great course
| BTW), but evidence for a hypothesis is always relative to another competing or alternative hypothesis.

...

  |============                                                                                            |  11%

| When presented with a claim that something is good, you should always ask "Compared to What?" This is why in
| commercials you often hear the phrase "other leading brands". An implicit comparison, right?

...

  |==============                                                                                          |  14%

| Consider this boxplot which shows the relationship between the use of an air cleaner and the number of
| symptom-free days of asthmatic children. (The top and bottom lines of the box indicate the 25% and 75%
| quartiles of the data, and the horizontal line in the box shows the 50%.) Since the box is above 0, the number
| of symptom-free days for children with asthma is bigger using the air cleaner. This is good, right?

...

  |=================                                                                                       |  17%

| How many days of improvement does the median correspond to?

1: -2
2: 12
3: 4
4: 1

Selection: 4

| You are doing so well!

  |====================                                                                                    |  19%

| While it's somewhat informative, it's also somewhat cryptic, since the y-axis is claiming to show a change in
| number of symptom-free days. Wouldn't it be better to show a comparison?

...

  |=======================                                                                                 |  22%

| Like this? Here's a graphic which shows two boxplots, the one on the left showing the results for a control
| group that doesn't use an air cleaner alongside the previously shown boxplot.

...

  |==========================                                                                              |  25%

| By showing the two boxplots side by side, you can clearly see that using the air cleaner increases the number
| of symptom-free days for most asthmatic children. The plot on the right (using the air cleaner) is generally
| higher than the one on the left (the control group).

...

  |=============================                                                                           |  28%

| What does this graph NOT show you?

1: Half the chidren in the control group had no improvement
2: 75% of the children using the air cleaner had at most 3 symptom-free days
3: Using the air cleaner makes asthmatic children sicker
4: Children in the control group had at most 3 symptom-free days

Selection: 3

| You are doing so well!

  |================================                                                                        |  31%

| So the first principle was to show a comparison. The second principle is to show
| causality or a mechanism of how your theory of the data works. This explanation or
| systematic structure shows your causal framework for thinking about the question you're
| trying to answer.

...

  |===================================                                                                     |  33%

| Consider this plot which shows the dual boxplot we just showed, but next to it we have a
| corresponding plot of changes in measures of particulate matter.

...

  |======================================                                                                  |  36%

| This picture tries to explain how the air cleaner increases the number of symptom-free
| days for asthmatic children. What mechanism does the graph imply?

1: That the air in the control group is cleaner than the air in the other group
2: That the air cleaner reduces pollution
3: That the air cleaner increases pollution
4: That the children in the control group are healthier

Selection: 2

| You're the best!

  |========================================                                                                |  39%

| By showing the two sets of boxplots side by side you're explaining your theory of why
| the air cleaner increases the number of symptom-free days. Onward!

...

  |===========================================                                                             |  42%

| So the first principle was to show some comparison, the second was to show a mechanism,
| so what will the third principle say to show?

...

  |==============================================                                                          |  44%

| Multivariate data!

...

  |=================================================                                                       |  47%

| What is multivariate data you might ask? In technical (scientific) literature this term
| means more than 2 variables. Two-variable plots are what you saw in high school algebra.
| Remember those x,y plots when you were learning about slopes and intercepts and
| equations of lines? They're valuable, but usually questions are more complicated and
| require more variables.

...

  |====================================================                                                    |  50%

| Sometimes, if you restrict yourself to two variables you'll be misled and draw an
| incorrect conclusion.

...

  |=======================================================                                                 |  53%

| Consider this plot which shows the relationship between air pollution (x-axis) and
| mortality rates among the elderly (y-axis). The blue regression line shows a surprising
| result. (You'll learn about regression lines when you take the fabulous Regression
| Models course.)

...

  |==========================================================                                              |  56%

| What does the blue regression line indicate?

1: As pollution increases the number of deaths doesn't change
2: Pollution doesn't really increase, it just gets reported more
3: As pollution increases fewer people die
4: As pollution increases more people die

Selection: 3

| That's the answer I was looking for.

  |=============================================================                                           |  58%

| Fewer deaths with more pollution? That's a surprise! Something's gotta be wrong, right?
| In fact, this is an example of Simpson's paradox, or the Yuleâ€“Simpson effect. Wikipedia
| (http://en.wikipedia.org/wiki/Simpson%27s_paradox) tells us that this "is a paradox in
| probability and statistics, in which a trend that appears in different groups of data
| disappears when these groups are combined."

...

  |================================================================                                        |  61%

| Suppose we divided this mortality/pollution data into the four seasons. Would we see
| different trends?

...

  |==================================================================                                      |  64%

| Yes, we do! Plotting the same data for the 4 seasons individually we see a different
| result.

...

  |=====================================================================                                   |  67%

| What does the new plot indicate?

1: As pollution increases the seasons change
2: As pollution increases more people die in all seasons
3: As pollution increases fewer people die in all seasons
4: Pollution doesn't really increase, it just gets reported more

Selection: 2

| You nailed it! Good job!

  |========================================================================                                |  69%

| The fourth principle of analytic graphing involves integrating evidence. This means not
| limiting yourself to one form of expression. You can use words, numbers, images as well
| as diagrams. Graphics should make use of many modes of data presentation. Remember,
| "Don't let the tool drive the analysis!"

...

  |===========================================================================                             |  72%

| To show you what we mean, here's an example of a figure taken from a paper published in
| the Journal of the AMA. It shows the relationship between pollution and hospitalization
| of people with heart disease. As you can see, it's a lot different from our previous
| plots. The solid circles in the center portion indicate point estimates of percentage
| changes in hospitalization rates for different levels of pollution. The lines through
| the circles indicate confidence intervals associated with these estimates. (You'll learn
| more about confidence intervals in another great course, the one on statistical
| inference.)

...

  |==============================================================================                          |  75%

| Note that on the right side of the figure is another column of numbers, one for each of
| the point estimates given. This column shows posterior probabilities that relative risk
| is greater than 0. This, in effect, is a measure of the strength of the evidence showing
| the correlation between pollution and hospitalization.  The point here is that all of
| this information is located in one picture so that the reader can see the strength of
| not only the correlations but the evidence as well.

...

  |=================================================================================                       |  78%

| The fifth principle of graphing involves describing and documenting the evidence with
| sources and appropriate labels and scales. Credibility is important so the data graphics
| should tell a complete story. Also, using R, you want to preserve any code you use to
| generate your data and graphics so that the research can be replicated if necessary.
| This allows for easy verification or finding bugs in your analysis.

...

  |====================================================================================                    |  81%

| The sixth and final principle of analytic graphing is maybe the most important. Content
| is king! If you don't have something interesting to report, your graphs won't save you.
| Analytical presentations ultimately stand or fall depending on the quality, relevance,
| and integrity of their content.

...

  |=======================================================================================                 |  83%

| Review time!!!

...

  |==========================================================================================              |  86%

| Which of the following is NOT a good principle of graphing?

1: Content is king
2: Having unreadable labels
3: To describe and document evidence
4: To integrate multiple modes of evidence

Selection: 2

| You're the best!

  |============================================================================================            |  89%

| Which of the following is NOT a good principle of graphing?

1: To demonstrate a causative mechanism underlying a correlation
2: To prove you're always right
3: To show two competing hypotheses
4: Content is king

Selection: 2

| You are doing so well!

  |===============================================================================================         |  92%

| Which of the following is NOT a good principle of graphing?

1: Content is king
2: To show good labels and scales
3: To show that some fonts are better than others
4: To integrate different types of evidence

Selection: 3

| You got it!

  |==================================================================================================      |  94%

| True or False? Color is king.

1: True
2: False

Selection: 2

| That's the answer I was looking for.

  |=====================================================================================================   |  97%

| Congrats! You've concluded exploring this lesson on principles of graphing. We hope you
| found it principally principled.

...

  |========================================================================================================| 100%
  
  
  
| Exploratory_Graphs. (Slides for this and other Data Science courses may be found at
| github https://github.com/DataScienceSpecialization/courses/. If you care to use them,
| they must be downloaded as a zip file and viewed locally. This lesson corresponds to
| 04_ExploratoryAnalysis/exploratoryGraphs.)

...

  |=                                                                                |   1%

| In this lesson, we'll discuss why graphics are an important tool for data scientists and
| the special role that exploratory graphs play in the field.

...

  |==                                                                               |   3%

| Which of the following would NOT be a good reason to use graphics in data science?

1: To find patterns in data
2: To find a color that best matches the shirt you're wearing
3: To understand data properties
4: To suggest modeling strategies

Selection: 2

| Keep up the great work!

  |===                                                                              |   4%

| So graphics give us some visual form of data, and since our brains are very good at
| seeing patterns, graphs give us a compact way to present data and find or display any
| pattern that may be present.

...

  |====                                                                             |   5%

| Which of the following cliches captures the essence of graphics?

1: A picture is worth a 1000 words
2: A rose by any other name smells as sweet
3: The apple doesn't fall far from the tree
4: To err is human, to forgive divine

Selection: 1

| Excellent job!

  |=====                                                                            |   7%

| Exploratory graphs serve mostly the same functions as graphs. They help us find patterns
| in data and understand its properties. They suggest modeling strategies and help to
| debug analyses. We DON'T use exploratory graphs to communicate results.

...

  |======                                                                           |   8%

| Instead, exploratory graphs are the initial step in an investigation, the "quick and
| dirty" tool used to point the data scientist in a fruitful direction. A scientist might
| need to make a lot of exploratory graphs in order to develop a personal understanding of
| the problem being studied. Plot details such as axes, legends, color and size are
| cleaned up later to convey more information in an aesthetically pleasing way.

...

  |========                                                                         |   9%

| To demonstrate these ideas, we've copied some data for you from the U.S. Environmental
| Protection Agency (EPA) which sets national ambient air quality standards for outdoor
| air pollution. These Standards say that for fine particle pollution (PM2.5), the "annual
| mean, averaged over 3 years" cannot exceed 12 micro grams per cubic meter. We stored the
| data from the U.S. EPA web site in the data frame pollution. Use the R function head to
| see the first few entries of pollution.

> 
> head(ppm)
[1]  9.771185  9.993817 10.688618 11.337424 12.119764 10.827805

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for
| more options.

| Type head(pollution) at the command prompt.

> head(pollution)
       pm25  fips region longitude latitude
1  9.771185 01003   east -87.74826 30.59278
2  9.993817 01027   east -85.84286 33.26581
3 10.688618 01033   east -87.72596 34.73148
4 11.337424 01049   east -85.79892 34.45913
5 12.119764 01055   east -86.03212 34.01860
6 10.827805 01069   east -85.35039 31.18973

| Keep working like that and you'll get there!

  |=========                                                                        |  11%

| We see right away that there's at least one county exceeding the EPA's standard of 12
| micrograms per cubic meter. What else do we see?

...

  |==========                                                                       |  12%

| We see 5 columns of data. The pollution count is in the first column labeled pm25. We'll
| work mostly with that. The other 4 columns are a fips code indicating the state (first 2
| digits) and county (last 3 digits) with that count, the associated region (east or
| west), and the longitude and latitude of the area. Now run the R command dim with
| pollution as an argument to see how long the table is.

> dim(pollution)
[1] 576   5

| You are really on a roll!

  |===========                                                                      |  13%

| So there are 576 entries in pollution. We'd like to investigate the question "Are there
| any counties in the U.S. that exceed that national standard (12 micro grams per cubic
| meter) for fine particle pollution?" We'll look at several one dimensional summaries of
| the data to investigate this question.

...

  |============                                                                     |  15%

| The first technique uses the R command summary, a 5-number summary which returns 6
| numbers. Run it now with the pm25 column of pollution as its argument. Recall that the
| construct for this is pollution$pm25.

> summary(pollution$pm25)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  3.383   8.549  10.050   9.836  11.360  18.440 

| You are really on a roll!

  |=============                                                                    |  16%

| This shows us basic info about the pm25 data, namely its Minimum (0 percentile) and
| Maximum (100 percentile) values, and three Quartiles of the data. These last indicate
| the pollution measures at which 25%, 50%, and 75% of the counties fall below. In
| addition to these 5 numbers we see the Mean or average measure of particulate pollution
| across the 576 counties.

...

  |==============                                                                   |  17%

| Half the measured counties have a pollution level less than or equal to what number of
| micrograms per cubic meter?

1: 9.836
2: 10.050
3: 11.360
4: 8.549

Selection: 2

| You are really on a roll!

  |===============                                                                  |  19%

| To save you a lot of typing we've saved off pollution$pm25 for you in the variable ppm.
| You can use ppm now in place of the longer expression. Try it now as the argument of the
| R command quantile. See how the results look a lot like the results of the output of the
| summary command.

> quantile(ppm)
       0%       25%       50%       75%      100% 
 3.382626  8.548799 10.046697 11.356012 18.440731 

| You are really on a roll!

  |================                                                                 |  20%

| See how the results are similar to those returned by summary? Quantile gives the
| quartiles, right? What is the one value missing from this quantile output that summary
| gave you?

1: the maximum value
2: the mean
3: the minimum value
4: the median

Selection: 2

| Your dedication is inspiring!

  |=================                                                                |  21%

| Now we'll plot a picture, specifically a boxplot. Run the R command boxplot with ppm as
| an input. Also specify the color parameter col equal to "blue".

> boxplot(ppm, col="blue")

| All that hard work is paying off!

  |==================                                                               |  23%

| The boxplot shows us the same quartile data that summary and quantile did. The lower and
| upper edges of the blue box respectively show the values of the 25% and 75% quantiles.

...

  |===================                                                              |  24%

| What do you think the horizontal line inside the box represents?

1: the mean
2: the median
3: the maximum value
4: the minimum value

Selection: 2

| All that hard work is paying off!

  |=====================                                                            |  25%

| The "whiskers" of the box (the vertical lines extending above and below the box) relate
| to the range parameter of boxplot, which we let default to the value 1.5 used by R. The
| height of the box is the interquartile range, the difference between the 75th and 25th
| quantiles. In this case that difference is 2.8. The whiskers are drawn to be a length of
| range*2.8 or 1.5*2.8. This shows us roughly how many, if any, data points are outliers,
| that is, beyond this range of values.

...

  |======================                                                           |  27%

| Note that boxplot is part of R's base plotting package. A nice feature that this package
| provides is its ability to overlay features. That is, you can add to (annotate) an
| existing plot.

...

  |=======================                                                          |  28%

| To see this, run the R command abline with the argument h equal to 12. Recall that 12 is
| the EPA standard for air quality.

> abline(h=12)

| All that practice is paying off!

  |========================                                                         |  29%

| What do you think this command did?

1: nothing
2: drew a horizontal line at 12
3: drew a vertical line at 12
4: hid 12 random data points

Selection: 2

| That's a job well done!

  |=========================                                                        |  31%

| So abline "adds one or more straight lines through the current plot." We see from the
| plot that the bulk of the measured counties comply with the standard since they fall
| under the line marking that standard.

...

  |==========================                                                       |  32%

| Now use the R command hist (another function from the base package) with the argument
| ppm. Specify the color parameter col equal to "green". This will plot a histogram of the
| data.

> hist(ppm, col="green")

| You are really on a roll!

  |===========================                                                      |  33%

| The histogram gives us a little more detailed information about our data, specifically
| the distribution of the pollution counts, or how many counties fall into each bucket of
| measurements.

...

  |============================                                                     |  35%

| What are the most frequent pollution counts?

1: under 5
2: between 6 and 8
3: between 9 and 12
4: between 12 and 14

Selection: 3

| That's correct!

  |=============================                                                    |  36%

| Now run the R command rug with the argument ppm.

> rug(ppm)

| You are really on a roll!

  |==============================                                                   |  37%

| This one-dimensional plot, with its grayscale representation, gives you a little more
| detailed information about how many data points are in each bucket and where they lie
| within the bucket. It shows (through density of tick marks) that the greatest
| concentration of counties has between 9 and 12 micrograms per cubic meter just as the
| histogram did.

...

  |===============================                                                  |  39%

| To illustrate this a little more, we've defined for you two vectors, high and low,
| containing pollution data of high (greater than 15) and low (less than 5) values
| respectively. Look at low now and see how it relates to the output of rug.

> low
 [1] 3.494351 4.186090 4.917140 4.504539 4.793644 4.601408 4.195688 4.625279 4.460193
[10] 4.978397 4.324736 4.175901 3.382626 4.132739 4.955570 4.565808

| Keep working like that and you'll get there!

  |================================                                                 |  40%

| It confirms that there are two data points between 3 and 4 and many between 4 and 5. Now
| look at high.

> high
[1] 16.19452 15.80378 18.44073 16.66180 15.01573 17.42905 16.25190 16.18358

| Great job!

  |=================================                                                |  41%

| Again, we see one data point greater than 18, one between 17 and 18, several between 16
| and 17 and two between 15 and 16, verifying what rug indicated.

...

  |===================================                                              |  43%

| Now rerun hist with 3 arguments, ppm as its first, col equal to "green", and the
| argument breaks equal to 100.

> hist(ppm, col="green", breaks = 100)

| You are quite good my friend!

  |====================================                                             |  44%

| What do you think the breaks argument specifies in this case?

1: the number of buckets to split the data into
2: the number of counties exceeding the EPA standard
3: the number of stars in the sky
4: the number of data points to graph

Selection: 1

| Excellent job!

  |=====================================                                            |  45%

| So this histogram with more buckets is not nearly as smooth as the preceding one. In
| fact, it's a little too noisy to see the distribution clearly. When you're plotting
| histograms you might have to experiment with the argument breaks to get a good idea of
| your data's distribution. For fun now, rerun the R command rug with the argument ppm.

> rug(ppm)

| That's the answer I was looking for.

  |======================================                                           |  47%

| See how rug works with the existing plot? It automatically adjusted its pocket size to
| that of the last plot plotted.

...

  |=======================================                                          |  48%

| Now rerun hist with ppm as the data and col equal to "green".

> hist(ppm, col="green")

| You got it right!

  |========================================                                         |  49%

| Now run the command abline with the argument v equal to 12 and the argument lwd equal to
| 2.

> abline(v=12, lwd=2)

| You're the best!

  |=========================================                                        |  51%

| See the vertical line at 12? Not very visible, is it, even though you specified a line
| width of 2? Run abline with the argument v equal to median(ppm), the argument col equal
| to "magenta", and the argument lwd equal to 4.

> abline(v=median(ppm), lwd=4)

| Give it another try. Or, type info() for more options.

| Type abline(v = median(ppm), col = "magenta", lwd = 4) at the command prompt.

> abline(v=median(ppm), lwd=4, col="magneta")
Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...) : 
  invalid color name 'magneta'
> abline(v=median(ppm), lwd=4, col="magenta")

| Not quite right, but keep trying. Or, type info() for more options.

| Type abline(v = median(ppm), col = "magenta", lwd = 4) at the command prompt.

> abline(v=median(ppm), col="magenta", lwd=4)

| Keep working like that and you'll get there!

  |==========================================                                       |  52%

| Better, right? Thicker and more of a contrast in color. This shows that although the
| median (50%) is below the standard, there are a fair number of counties in the U.S that
| have pollution levels higher than the standard.

...

  |===========================================                                      |  53%

| Now recall that our pollution data had 5 columns of information. So far we've only
| looked at the pm25 column. We can also look at other information. To remind yourself
| what's there run the R command names with pollution as the argument.

> names(pollution)
[1] "pm25"      "fips"      "region"    "longitude" "latitude" 

| All that practice is paying off!

  |============================================                                     |  55%

| Longitude and latitude don't sound interesting, and each fips is unique since it
| identifies states (first 2 digits) and counties (last 3 digits). Let's look at the
| region column to see what's there. Run the R command table on this column. Use the
| construct pollution$region. Store the result in the variable reg.

> reg <- table(pollution$region)

| Your dedication is inspiring!

  |=============================================                                    |  56%

| Look at reg now.

> reg

east west 
 442  134 

| Great job!

  |==============================================                                   |  57%

| Lot more counties in the east than west. We'll use the R command barplot (another type
| of one-dimensional summary) to plot this information. Call barplot with reg as its first
| argument, the argument col equal to "wheat", and the argument main equal to the string
| "Number of Counties in Each Region".

> barplot(reg, col="wheat", main="Number of Counties in Each Region")

| Excellent work!

  |================================================                                 |  59%

| What do you think the argument main specifies?

1: I can't tell
2: the title of the graph
3: the y axis label
4: the x axis label

Selection: 2

| You got it!

  |=================================================                                |  60%

| So we've seen several examples of one-dimensional graphs that summarize data. Two
| dimensional graphs include scatterplots, multiple graphs which we'll see more examples
| of, and overlayed one-dimensional plots which the R packages such as lattice and ggplot2
| provide.

...

  |==================================================                               |  61%

| Some graphs have more than two-dimensions. These include overlayed or multiple
| two-dimensional plots and spinning plots. Some three-dimensional plots are tricky to
| understand so have limited applications. We'll see some examples now of more complicated
| graphs, in particular, we'll show two graphs together.

...

  |===================================================                              |  63%

| First we'll show how R, in one line and using base plotting, can display multiple
| boxplots. We simply specify that we want to see the pollution data as a function of
| region. We know that our pollution data characterized each of the 576 entries as
| belonging to one of two regions (east and west).

...

  |====================================================                             |  64%

| We use the R formula y ~ x to show that y (in this case pm25) depends on x (region).
| Since both come from the same data frame (pollution) we can specify a data argument set
| equal to pollution. By doing this, we don't have to type pollution$pm25 (or ppm) and
| pollution$region. We can just specify the formula pm25~region. Call boxplot now with
| this formula as its argument, data equal to pollution, and col equal to "red".

> 
> boxplot(pm25~region, data=pollution, col="red")

| That's correct!

  |=====================================================                            |  65%

| Two for the price of one! Similarly we can plot multiple histograms in one plot, though
| to do this we have to use more than one R command. First we have to set up the plot
| window with the R command par which specifies how we want to lay out the plots, say one
| above the other. We also use par to specify margins, a 4-long vector which indicates the
| number of lines for the bottom, left, top and right. Type the R command
| par(mfrow=c(2,1),mar=c(4,4,2,1)) now. Don't expect to see any new result.

> par(mfrow=c(2,1),mar=c(4,4,2,1))

| That's a job well done!

  |======================================================                           |  67%

| So we set up the plot window for two rows and one column with the mfrow argument. The
| mar argument set up the margins. Before we plot the histograms let's explore the R
| command subset which, not surprisingly, "returns subsets of vectors, matrices or data
| frames which meet conditions". We'll use subset to pull off the data we want to plot.
| Call subset now with pollution as its first argument and a boolean expression testing
| region for equality with the string "east". Put the result in the variable east.

> east <- subset(pollution, region == "east")

| Great job!

  |=======================================================                          |  68%

| Use head to look at the first few entries of east.

> head(east)
       pm25  fips region longitude latitude
1  9.771185 01003   east -87.74826 30.59278
2  9.993817 01027   east -85.84286 33.26581
3 10.688618 01033   east -87.72596 34.73148
4 11.337424 01049   east -85.79892 34.45913
5 12.119764 01055   east -86.03212 34.01860
6 10.827805 01069   east -85.35039 31.18973

| You got it!

  |========================================================                         |  69%

| So east holds more information than we need. We just want to plot a histogram with the
| pm25 portion. Call hist now with the pm25 portion of east as its first argument and col
| equal to "green" as its second.

> hist(east$ppm, col="green")
Error in hist.default(east$ppm, col = "green") : 'x' must be numeric
> hist(east$pm25, col="green")

| You are amazing!

  |=========================================================                        |  71%

| See? The command par told R we were going to have one column with 2 rows, so it placed
| this histogram in the top position.

...

  |==========================================================                       |  72%

| Now, here's a challenge for you. Plot the histogram of the counties from the west using
| just one R command. Let the appropriate subset command (with the pm25 portion specified)
| be the first argument and col (equal to "green") the second.  To cut down on your
| typing, use the up arrow key to get your last command and replace "east" with the subset
| command. Make sure the boolean argument checks for equality between region and "west".

> hist(subset(pollution, region == "west"), col="green")
Error in hist.default(subset(pollution, region == "west"), col = "green") : 
  'x' must be numeric
> hist(subset(pollution, region == "west")$pm25, col="green")

| Great job!

  |===========================================================                      |  73%

| See how R does all the labeling for you? Notice that the titles are different since we
| used different commands for the two plots. Let's look at some scatter plots now.

...

  |============================================================                     |  75%

| Scatter plots are two-dimensional plots which show the relationship between two
| variables, usually x and y. Let's look at a scatterplot showing the relationship between
| latitude and the pm25 data. We'll use plot, a function from R's base plotting package.

...

  |==============================================================                   |  76%

| We've seen that we can use a function call as an argument when calling another function.
| We'll do this again when we call plot with the arguments latitude and pm25 which are
| both from our data frame pollution. We'll call plot from inside the R command with which
| evaluates "an R expression in an environment constructed from data". We'll use pollution
| as the first argument to with and the call to plot as the second. This allows us to
| avoid typing "pollution$" before the arguents to plot, so it saves us some typing and
| adds to your base of R knowledge. Try this now.

> View(pollution)

| You almost had it, but not quite. Try again. Or, type info() for more options.

| Type with(pollution, plot(latitude, pm25)) at the command prompt.

> with(pollution, plot(latitude, pm25))

| You are quite good my friend!

  |===============================================================                  |  77%

| Note that the first argument is plotted along the x-axis and the second along the y. Now
| use abline to add a horizontal line at 12. Use two additional arguments, lwd equal to 2
| and lty also equal to 2. See what happens.

> abline(h=12, lwd=2, lty=2)

| You're the best!

  |================================================================                 |  79%

| See how lty=2 made the line dashed? Now let's replot the scatterplot. This time, instead
| of using with, call plot directly with 3 arguments. The first 2 are pollution$latitude
| and ppm. The third argument, col, we'll use to add color and more information to our
| plot. Set this argument (col) equal to pollution$region and see what happens.

> plot(pollution$latitude, pollution$ppm, col=pollution$region)

| Almost! Try again. Or, type info() for more options.

| Type plot(pollution$latitude, ppm, col = pollution$region) at the command prompt.

> plot(pollution$latitude, ppm, col=pollution$region)

| You are doing so well!

  |=================================================================                |  80%

| We've got two colors on the map to distiguish between counties in the east and those in
| the west. Can we figure out which color is east and which west? See that the high
| (greater than 50) and low (less than 25) latitudes are both red. Latitudes indicate
| distance from the equator, so which half of the U.S. (east or west) has counties at the
| extreme north and south?

1: west
2: east

Selection: 1

| That's a job well done!

  |==================================================================               |  81%

| As before, use abline to add a horizontal line at 12. Use two additional arguments, lwd
| equal to 2 and lty also equal to 2.

> abline(h=12, lwd=2, lty=2)

| You are doing so well!

  |===================================================================              |  83%

| We see many counties are above the healthy standard set by the EPA, but it's hard to
| tell overall, which region, east or west, is worse.

...

  |====================================================================             |  84%

| Let's plot two scatterplots distinguished by region.

...

  |=====================================================================            |  85%

| As we did with multiple histograms, we first have to set up the plot window with the R
| command par. This time, let's plot the scatterplots side by side (one row and two
| columns). We also need to use different margins. Type the R command par(mfrow = c(1, 2),
| mar = c(5, 4, 2, 1)) now. Don't expect to see any new result.

> par(mfrow = c(1, 2),
+      mar = c(5, 4, 2, 1))

| You are really on a roll!

  |======================================================================           |  87%

| For the first scatterplot, on the left, we'll plot the latitudes and pm25 counts from
| the west. We already pulled out the information for the counties in the east. Let's now
| get the information for the counties from the west. Create the variable west by using
| the subset command with pollution as the first argument and the appropriate boolean as
| the second.

> west <- subset(pollution, region == "west")

| You got it!

  |=======================================================================          |  88%

| Now call plot with three arguments. These are west$latitude (x-axis), west$pm25
| (y-axis), and the argument main equal to the string "West" (title). Do this now.

> plot(west$latitude, west$pm25, main="west")

| Almost! Try again. Or, type info() for more options.

| Type plot(west$latitude, west$pm25, main = "West") at the command prompt.

> plot(west$latitude, west$pm25, main = "West")

| You're the best!

  |========================================================================         |  89%

| For the second scatterplot, on the right, we'll plot the latitudes and pm25 counts from
| the east.

...

  |=========================================================================        |  91%

| As before, use the up arrow key and change the 3 "west" strings to "east".

> plot(east$latitude, east$pm25, main = "east")

| You're close...I can feel it! Try it again. Or, type info() for more options.

| Type plot(east$latitude, east$pm25, main = "East") at the command prompt.

> plot(east$latitude, east$pm25, main = "East")

| You got it right!

  |===========================================================================      |  92%

| See how R took care of all the details for you? Nice, right? It looks like there are
| more dirty counties in the east but the extreme dirt (greater than 15) is in the west.

...

  |============================================================================     |  93%

| Let's summarize and review.

...

  |=============================================================================    |  95%

| Which of the following characterizes exploratory plots?

1: slow and clean
2: quick and dirty
3: slow and steady
4: quick and dead

Selection: 2

| You are really on a roll!

  |==============================================================================   |  96%

| True or false? Plots let you summarize the data (usually graphically) and highlight any
| broad features

1: False
2: True

Selection: 2

| Excellent job!

  |===============================================================================  |  97%

| Which of the following do plots NOT do?

1: Conclude that you are ALWAYS right
2: Summarize the data (usually graphically) and highlight any broad features
3: Explore basic questions and hypotheses (and perhaps rule them out)
4: Suggest modeling strategies for the "next step"

Selection: 1

| Keep working like that and you'll get there!

  |================================================================================ |  99%

| Congrats! You've concluded exploring this lesson on graphics. We hope you didn't find it
| too quick or dirty.

...

  |=================================================================================| 100%
  
  
  
| Graphics_Devices_in_R. (Slides for this and other Data Science courses may be found at
| github https://github.com/DataScienceSpecialization/courses/. If you care to use them,
| they must be downloaded as a zip file and viewed locally. This lesson corresponds to
| 04_ExploratoryAnalysis/Graphics_Devices_in_R.)

...

  |==                                                                               |   3%

| As the title suggests, this will be a short lesson introducing you to graphics devices
| in R. So, what IS a graphics device?

...

  |=====                                                                            |   6%

| Would you believe that it is something where you can make a plot appear, either a screen
| device, such as a window on your computer, OR a file device?

...

  |=======                                                                          |   9%

| There are several different kinds of file devices with particular characteristics and
| hence uses. These include PDF, PNG, JPEG, SVG, and TIFF. We'll talk more about these
| later.

...

  |==========                                                                       |  12%

| To be clear, when you make a plot in R, it has to be "sent" to a specific graphics
| device. Usually this is the screen (the default device), especially when you're doing
| exploratory work. You'll send your plots to files when you're ready to publish a report,
| make a presentation, or send info to colleagues.

...

  |============                                                                     |  15%

| How you access your screen device depends on what computer system you're using. On a Mac
| the screen device is launched with the call quartz(), on Windows you use the call
| windows(), and on Unix/Linux x11().  On a given platform (Mac, Windows, Unix/Linux)
| there is only one screen device, and obviously not all graphics devices are available on
| all platforms (i.e. you cannot launch windows() on a Mac).

...

  |==============                                                                   |  18%

| Run the R command ?Devices to see what graphics devices are available on your system.

> ?Devices

| All that hard work is paying off!

  |=================                                                                |  21%

| R Documentation shows you what's available.

...

  |===================                                                              |  24%

| There are two basic approaches to plotting. The first, plotting to the screen, is the
| most common. It's simple - you call a plotting function like plot, xyplot, or qplot
| (which you call depends on the plotting system you favor, but that's another lesson), so
| that the plot appears on the screen. Then you annotate (add to) the plot if necessary.

...

  |=====================                                                            |  26%

| As an example, run the R command with with 2 arguments. The first is a dataset,
| faithful, which comes with R, and the second is a call to the base plotting function
| plot. Your call to plot should have two arguments, eruptions and waiting. Try this now
| to see what happens.

> 
> with(faithful, plot(eruptions, waiting))

| All that practice is paying off!

  |========================                                                         |  29%

| See how R created a scatterplot on the screen for you? This shows that relationship
| between eruptions of the geyser Old Faithful and waiting time. Now use the R function
| title with the argument main set equal to the string "Old Faithful Geyser data". This is
| an annotation to the plot.

> title("Old Faithful Geyser data")

| You got it right!

  |==========================                                                       |  32%

| Simple, right?  Now run the command dev.cur(). This will show you the current plotting
| device, the screen.

> dev.cur()
RStudioGD 
        2 

| That's the answer I was looking for.

  |=============================                                                    |  35%

| The second way to create a plot is to send it to a file device. Depending on the type of
| plot you're making, you explicitly launch a graphics device, e.g., a pdf file. Type the
| command pdf(file="myplot.pdf") to launch the file device. This will create the pdf file
| myplot.pdf in your working directory.

> pdf(file="myplot.pdf")

| You're the best!

  |===============================                                                  |  38%

| You then call the plotting function (if you are using a file device, no plot will appear
| on the screen). Run the with command again to plot the Old Faithful data. Use the up
| arrow key to recover the command and save yourself some typing.

> with(faithful, plot(eruptions, waiting))

| You are quite good my friend!

  |=================================                                                |  41%

| Now rerun the title command and annotate the plot. (Up arrow keys are great!)

> title("Old Faithful Geyser data")

| Great job!

  |====================================                                             |  44%

| Finally, when plotting to a file device, you have to close the device with the command
| dev.off(). This is very important! Don't do it yet, though. After closing, you'll be
| able to view the pdf file on your computer.

...

  |======================================                                           |  47%

| There are two basic types of file devices, vector and bitmap devices. These use
| different formats and have different characteristics. Vector formats are good for line
| drawings and plots with solid colors using a modest number of points, while bitmap
| formats are good for plots with a large number of points, natural scenes or web-based
| plots.

...

  |========================================                                         |  50%

| We'll mention 4 specific vector formats. The first is pdf, which we've just used in our
| example. This is useful for line-type graphics and papers. It resizes well, is usually
| portable, but it is not efficient if a plot has many objects/points.

...

  |===========================================                                      |  53%

| The second is svg which is XML-based, scalable vector graphics. This supports animation
| and interactivity and is potentially useful for web-based plots.

...

  |=============================================                                    |  56%

| The last two vector formats are win.metafile, a Windows-only metafile format, and
| postscript (ps), an older format which also resizes well, is usually portable, and can
| be used to create encapsulated postscript files. Unfortunately, Windows systems often
| donâ€™t have a postscript viewer.

...

  |================================================                                 |  59%

| We'll also mention 4 different bitmap formats. The first is png (Portable Network
| Graphics) which is good for line drawings or images with solid colors. It uses lossless
| compression (like the old GIF format), and most web browsers can read this format
| natively. In addition, png is good for plots with many points, but it does not resize
| well.

...

  |==================================================                               |  62%

| In contrast, jpeg files are good for photographs or natural scenes. They use lossy
| compression, so they're good for plots with many points. Files in jpeg format don't
| resize well, but they can be read by almost any computer and any web browser. They're
| not great for line drawings.

...

  |====================================================                             |  65%

| The last two bitmap formats are tiff, an older lossless compression meta-format and bmp
| which is a native Windows bitmapped format.

...

  |=======================================================                          |  68%

| Although it is possible to open multiple graphics devices (screen, file, or both), when
| viewing multiple plots at once, plotting can only occur on one graphics device at a
| time.

...

  |=========================================================                        |  71%

| The currently active graphics device can be found by calling dev.cur(). Try it now to
| see what number is assigned to your pdf device.

> dev.cur()
pdf 
  4 

| You are quite good my friend!

  |============================================================                     |  74%

| Now use dev.off() to close the device.

> dev.off()
RStudioGD 
        2 

| Excellent work!

  |==============================================================                   |  76%

| Now rerun dev.cur() to see what integer your plotting window is assigned.

> dev.cur()
RStudioGD 
        2 

| All that hard work is paying off!

  |================================================================                 |  79%

| The device is back to what it was when you started. As you might have guessed, every
| open graphics device is assigned an integer greater than or equal to 2. You can change
| the active graphics device with dev.set(<integer>) where <integer> is the number
| associated with the graphics device you want to switch to.

...

  |===================================================================              |  82%

| You can also copy a plot from one device to another. This can save you some time but
| beware! Copying a plot is not an exact operation, so the result may not be identical to
| the original. R provides some functions to help you do this. The function dev.copy
| copies a plot from one device to another, and dev.copy2pdf specifically copies a plot to
| a PDF file.

...

  |=====================================================================            |  85%

| Just for fun, rerun the with command again, with(faithful, plot(eruptions, waiting)), to
| plot the Old Faithful data. Use the up arrow key to recover the command if you don't
| feel like typing.

> with(faithful, plot(eruptions, waiting))

| You are quite good my friend!

  |=======================================================================          |  88%

| Now rerun the title command, title(main = "Old Faithful Geyser data"), to annotate the
| plot. (Up arrow keys are great!)

> title("Old Faithful Geyser data")

| Keep up the great work!

  |==========================================================================       |  91%

| Now run dev.copy with the 2 arguments. The first is png, and the second is file set
| equal to "geyserplot.png". This will copy your screen plot to a png file in your working
| directory which you can view AFTER you close the device.

> dev.copy(png, "geyserplot.png")
png 
  4 

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| Type dev.copy(png, file = "geyserplot.png") at the command prompt.

> dev.copy(png, file = "geyserplot.png")
png 
  5 

| Keep up the great work!

  |============================================================================     |  94%

| Don't forget to close the PNG device! Do it NOW!!! Then you'll be able to view the file.

> dev.off()
RStudioGD 
        2 

| Keep up the great work!

  |===============================================================================  |  97%

| Congrats! We hope you found this lesson deviced well!

...

  |=================================================================================| 100%
  
  

| Plotting_Systems. (Slides for this and other Data Science courses may be found at github
| https://github.com/DataScienceSpecialization/courses/. If you care to use them, they
| must be downloaded as a zip file and viewed locally. This lesson corresponds to
| 04_ExploratoryAnalysis/PlottingSystems.)

...

  |==                                                                               |   3%

| In this lesson, we'll give you a brief overview of the three plotting systems in R,
| their differences, strengths, and weaknesses. We'll only cover the basics here to give
| you a general idea of the systems and in later lessons we'll cover each system in more
| depth.

...

  |====                                                                             |   5%

| The first plotting system is the Base Plotting System which comes with R. It's the
| oldest system which uses a simple "Artist's palette" model. What this means is that you
| start with a blank canvas and build your plot up from there, step by step.

...

  |=======                                                                          |   8%

| Usually you start with a plot function (or something similar), then you use annotation
| functions to add to or modify your plot. R provides many annotating functions such as
| text, lines, points, and axis. R provides documentation for each of these. They all add
| to an already existing plot.

...

  |=========                                                                        |  11%

| What do you think is a disadvantage of the Base Plotting System?

1: It's intuitive and exploratory
2: A complicated plot is a series of simple R commands
3: It mirrors how we think of building plots and analyzing data
4: You can't go back once a plot has started

Selection: 2

| You almost had it, but not quite. Try again.

| Which choice has a negative contraction in it?

1: It's intuitive and exploratory
2: A complicated plot is a series of simple R commands
3: It mirrors how we think of building plots and analyzing data
4: You can't go back once a plot has started

Selection: 4

| You're the best!

  |===========                                                                      |  14%

| Yes! The base system is very intuitive and easy to use when you're starting to do
| exploratory graphing and looking for a research direction. You can't go backwards,
| though, say, if you need to readjust margins or fix a misspelled a caption. A finished
| plot will be a series of R commands, so it's difficult to translate a finished plot into
| a different system.

...

  |=============                                                                    |  16%

| We've loaded the dataset cars for you to demonstrate how easy it is to plot. First, use
| the R command head with cars as an argument to see what the data looks like.

> head(cars)
  speed dist
1     4    2
2     4   10
3     7    4
4     7   22
5     8   16
6     9   10

| That's correct!

  |===============                                                                  |  19%

| So the dataset collates the speeds and distances needed to stop for 50 cars. This data
| was recorded in the 1920's.

...

  |==================                                                               |  22%

| We'll use the R command with which takes two arguments. The first specifies a dataset or
| environment in which to run the second argument, an R expression. This will save us a
| bit of typing. Try running the command with now using cars as the first argument and a
| call to plot as the second. The call to plot will take two arguments, speed and dist.
| Please specify them in that order.

> with(cars, plot(speed, dist))

| You got it right!

  |====================                                                             |  24%

| Simple, right? You can see the relationship between the two variables, speed and
| distance. The first variable is plotted along the x-axis and the second along the
| y-axis.

...

  |======================                                                           |  27%

| Now we'll show you what the function text does. Run the command text with three
| arguments. The first two, x and y coordinates, specify the placement of the third
| argument, the text to be added to the plot. Let the first argument be mean(cars$speed),
| the second max(cars$dist), and the third the string "SWIRL rules!". Try it now.

> text(mean(cars$speed),max(cars$dist),"SWIRL rules!")

| All that hard work is paying off!

  |========================                                                         |  30%

| Ain't it the truth?

...

  |==========================                                                       |  32%

| Now we'll move on to the second plotting system, the Lattice System which comes in the
| package of the same name. Unlike the Base System, lattice plots are created with a
| single function call such as xyplot or bwplot. Margins and spacing are set automatically
| because the entire plot is specified at once.

...

  |============================                                                     |  35%

| The lattice system is most useful for conditioning types of plots which display how y
| changes with x across levels of z. The variable z might be a categorical variable of
| your data. This system is also good for putting many plots on a screen at once.

...

  |===============================                                                  |  38%

| The lattice system has several disadvantages. First, it is sometimes awkward to specify
| an entire plot in a single function call. Annotating a plot may not be especially
| intuitive. Second, using panel functions and subscripts is somewhat difficult and
| requires preparation. Finally, you cannot "add" to the plot once it is created as you
| can with the base system.

...

  |=================================                                                |  41%

| As before, we've loaded some data for you in the variable state. This data comes with
| the lattice package and it concerns various characteristics of the 50 states in the U.S.
| Use the R command head to see the first few entries of state now.

> head(state)
           Population Income Illiteracy Life.Exp Murder HS.Grad Frost   Area region
Alabama          3615   3624        2.1    69.05   15.1    41.3    20  50708  South
Alaska            365   6315        1.5    69.31   11.3    66.7   152 566432   West
Arizona          2212   4530        1.8    70.55    7.8    58.1    15 113417   West
Arkansas         2110   3378        1.9    70.66   10.1    39.9    65  51945  South
California      21198   5114        1.1    71.71   10.3    62.6    20 156361   West
Colorado         2541   4884        0.7    72.06    6.8    63.9   166 103766   West

| Keep working like that and you'll get there!

  |===================================                                              |  43%

| As you can see state holds 9 pieces of information for each of the 50 states. The last
| variable, region, specifies a category for each state. Run the R command table with the
| argument state$region to see how many categories there are and how many states are in
| each.

> table(state$region)

    Northeast         South North Central          West 
            9            16            12            13 

| Perseverance, that's the answer.

  |=====================================                                            |  46%

| So there are 4 categories and the 50 states are sorted into them appropriately. Let's
| use the lattice command xyplot to see how life expectancy varies with income in each of
| the four regions.

...

  |=======================================                                          |  49%

| To do this we'll give xyplot 3 arguments. The first is the most complicated. It is this
| R formula, Life.Exp ~ Income | region, which indicates we're plotting life expectancy as
| it depends on income for each region. The second argument, data, is set equal to state.
| This allows us to use "Life.Exp" and "Income" in the formula instead of specifying the
| dataset state for each term (as in state$Income). The third argument, layout, is set
| equal to the two-long vector c(4,1). Run xyplot now with these three arguments.

> xyplot(Life.Exp ~ Income | region, data=state, c(4,1))
Warning message:
In if (multiple) { :
  the condition has length > 1 and only the first element will be used

| Try again. Getting it right on the first try is boring anyway! Or, type info() for more
| options.

| Type xyplot(Life.Exp ~ Income | region, data = state, layout = c(4, 1)) at the command
| prompt.

> xyplot(Life.Exp ~ Income | region, data=state, layout=c(4,1))

| You are quite good my friend!

  |==========================================                                       |  51%

| We see the data for each of the 4 regions plotted in one row. Based on this plot, which
| region of the U.S. seems to have the shortest life expectancy?

1: South
2: Northeast
3: North Central
4: West

Selection: 1

| You got it right!

  |============================================                                     |  54%

| Just for fun rerun the xyplot and this time set layout to the vector c(2,2). To save
| typing use the up arrow to recover the previous xyplot command.

> xyplot(Life.Exp ~ Income | region, data=state, layout=c(2,2))

| Excellent work!

  |==============================================                                   |  57%

| See how the plot changed? No need for you to worry about margins or labels. The package
| took care of all that for you.

...

  |================================================                                 |  59%

| Now for the last plotting system, ggplot2, which is a hybrid of the base and lattice
| systems. It automatically deals with spacing, text, titles (as Lattice does) but also
| allows you to annotate by "adding" to a plot (as Base does), so it's the best of both
| worlds.

...

  |==================================================                               |  62%

| Although ggplot2 bears a superficial similarity to lattice, it's generally easier and
| more intuitive to use. Its default mode makes many choices for you but you can still
| customize a lot. The package is based on a "grammar of graphics" (hence the gg in the
| name), so you can control the aesthetics of your plots. For instance, you can plot
| conditioning graphs and panel plots as we did in the lattice example.

...

  |=====================================================                            |  65%

| We'll see an example now of ggplot2 with a simple (single) command. As before, we've
| loaded a dataset for you from the ggplot2 package. This mpg data holds fuel economy data
| between 1999 and 2008 for 38 different models of cars. Run head with mpg as an argument
| so you get an idea of what the data looks like.

> 
> head(mpg)
  manufacturer model displ year cyl      trans drv cty hwy fl   class
1         audi    a4   1.8 1999   4   auto(l5)   f  18  29  p compact
2         audi    a4   1.8 1999   4 manual(m5)   f  21  29  p compact
3         audi    a4   2.0 2008   4 manual(m6)   f  20  31  p compact
4         audi    a4   2.0 2008   4   auto(av)   f  21  30  p compact
5         audi    a4   2.8 1999   6   auto(l5)   f  16  26  p compact
6         audi    a4   2.8 1999   6 manual(m5)   f  18  26  p compact

| Keep working like that and you'll get there!

  |=======================================================                          |  68%

| Looks complicated. Run dim with the argument mpg to see how big the dataset is.

> dim(mpg)
[1] 234  11

| All that hard work is paying off!

  |=========================================================                        |  70%

| Holy cow! That's a lot of information for just 38 models of cars. Run the R command
| table with the argument mpg$model. This will tell us how many models of cars we're
| dealing with.

> table(mpg$model)

           4runner 4wd                     a4             a4 quattro 
                     6                      7                      8 
            a6 quattro                 altima     c1500 suburban 2wd 
                     3                      6                      5 
                 camry           camry solara            caravan 2wd 
                     7                      7                     11 
                 civic                corolla               corvette 
                     9                      5                      5 
     dakota pickup 4wd            durango 4wd         expedition 2wd 
                     9                      7                      3 
          explorer 4wd        f150 pickup 4wd           forester awd 
                     6                      7                      6 
    grand cherokee 4wd             grand prix                    gti 
                     8                      5                      5 
           impreza awd                  jetta        k1500 tahoe 4wd 
                     8                      9                      4 
land cruiser wagon 4wd                 malibu                 maxima 
                     2                      5                      3 
       mountaineer 4wd                mustang          navigator 2wd 
                     4                      9                      3 
            new beetle                 passat         pathfinder 4wd 
                     6                      7                      4 
   ram 1500 pickup 4wd            range rover                 sonata 
                    10                      4                      7 
               tiburon      toyota tacoma 4wd 
                     7                      7 

| All that practice is paying off!

  |===========================================================                      |  73%

| Oh, there are 38 models. We're interested in the effect engine displacement (displ) has
| on highway gas mileage (hwy), so we'll use the ggplot2 command qplot to display this
| relationship. Run qplot now with three arguments. The first two are the variables displ
| and hwy we want to plot, and the third is the argument data set equal to mpg. As before,
| this allows us to avoid using the mpg$variable notation for the first two arguments.

> qplot(displ, mwy, data=mpg)
Error in eval(expr, envir, enclos) : object 'mwy' not found
> qplot(displ, hwy, data=mpg)

| Keep up the great work!

  |=============================================================                    |  76%

| Not surprisingly we see that the bigger the engine displacement the lower the gas
| mileage.

...

  |===============================================================                  |  78%

| Let's review!

...

  |==================================================================               |  81%

| Which R plotting system is based on an artist's palette?

1: ggplot2
2: base
3: lattice
4: Winsor&Newton

Selection: 2

| That's a job well done!

  |====================================================================             |  84%

| Which R plotting system does NOT allow you to annotate plots with separate calls?

1: ggplot2
2: base
3: lattice
4: Winsor&Newton

Selection: 3

| Your dedication is inspiring!

  |======================================================================           |  86%

| Which R plotting system combines the best features of the other two?

1: ggplot2
2: lattice
3: base
4: Winsor&Newton

Selection: 1

| You are amazing!

  |========================================================================         |  89%

| Which R plotting system uses a graphics grammar?

1: ggplot2
2: lattice
3: base
4: Winsor&Newton

Selection: 1

| All that practice is paying off!

  |==========================================================================       |  92%

| Which R plotting system forces you to make your entire plot with one call?

1: ggplot2
2: base
3: Winsor&Newton
4: lattice

Selection: 4

| All that practice is paying off!

  |=============================================================================    |  95%

| Which of the following sells high quality artists' brushes?

1: base
2: ggplot2
3: Winsor&Newton
4: lattice

Selection: 3

| You're the best!

  |===============================================================================  |  97%

| Congrats! You've concluded this plotting lesson. We hope you didn't find it plodding.

...

  |=================================================================================| 100%
  
  

| Base_Plotting_System. (Slides for this and other Data Science courses may be found at
| github https://github.com/DataScienceSpecialization/courses/. If you care to use them,
| they must be downloaded as a zip file and viewed locally. This lesson corresponds to
| 04_ExploratoryAnalysis/PlottingBase.)

...

  |=                                                                                |   2%

| In another lesson, we gave you an overview of the three plotting systems in R. In this
| lesson we'll focus on the base plotting system and talk more about how you can exploit
| all its many parameters to get the plot you want.  We'll focus on using the base
| plotting system to create graphics on the screen device rather than another graphics
| device.

...

  |==                                                                               |   3%

| The core plotting and graphics engine in R is encapsulated in two packages. The first is
| the graphics package which contains plotting functions for the "base" system. The
| functions in this package include plot, hist, boxplot, barplot, etc. The second package
| is grDevices which contains all the code implementing the various graphics devices,
| including X11, PDF, PostScript, PNG, etc.

...

  |====                                                                             |   5%

| Base graphics are often constructed piecemeal, with each aspect of the plot handled
| separately through a particular function call. Usually you start with a plot function
| (such as plot, hist, or boxplot), then you use annotation functions (text, abline,
| points) to add to or modify your plot.

...

  |=====                                                                            |   6%

| Before making a plot you have to determine where the plot will appear and what it will
| be used for.  Is there a large amount of data going into the plot? Or is it just a few
| points? Do you need to be able to dynamically resize the graphic?

...

  |======                                                                           |   8%

| What do you think is a disadvantage of the Base Plotting System?

1: It mirrors how we think of building plots and analyzing data
2: A complicated plot is a series of simple R commands
3: It's intuitive and exploratory
4: You can't go back once a plot has started

Selection: 4

| Excellent work!

  |=======                                                                          |   9%

| Yes! The base system is very intuitive and easy to use. You can't go backwards, though,
| say, if you need to readjust margins or have misspelled a caption. A finished plot will
| be a series of R commands, so it's difficult to translate a finished plot into a
| different system.

...

  |=========                                                                        |  11%

| Calling a basic routine such as plot(x, y) or hist(x) launches a graphics device (if one
| is not already open) and draws a new plot on the device. If the arguments to plot or
| hist are not of some special class, then the default method is called.

...

  |==========                                                                       |  12%

| As you'll see, most of the base plotting functions have many arguments, for example,
| setting the title, labels of axes, plot character, etc. Some of the parameters can be
| set when you call the function or they can be added later in a separate function call.

...

  |===========                                                                      |  14%

| Now we'll go through some quick examples of basic plotting before we delve into gory
| details. We'll use the dataset airquality (part of the library datasets) which we've
| loaded for you. This shows ozone and other air measurements for New York City for 5
| months in 1973.

...

  |============                                                                     |  15%

| Use the R command head with airquality as an argument to see what the data looks like.

> head(airquality)
  Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2
3    12     149 12.6   74     5   3
4    18     313 11.5   62     5   4
5    NA      NA 14.3   56     5   5
6    28      NA 14.9   66     5   6

| Nice work!

  |==============                                                                   |  17%

| We see the dataset contains 6 columns of data. Run the command range with two arguments.
| The first is the ozone column of airquality, specified by airquality$Ozone, and the
| second is the boolean na.rm set equal to TRUE. If you don't specify this second
| argument, you won't get a meaningful result.

> range(airquality$Ozone, na.rm = TRUE)
[1]   1 168

| Nice work!

  |===============                                                                  |  18%

| So the measurements range from 1 to 168. First we'll do a simple histogram of this ozone
| column to show the distribution of measurements. Use the R command hist with the
| argument airquality$Ozone.

> hist(airquality$Ozone
+ )

| You are really on a roll!

  |================                                                                 |  20%

| Simple, right? R put a title on the histogram and labeled both axes for you. What is the
| most frequent count?

1: Over 150
2: Between 60 and 75
3: Under 25
4: Over 100

Selection: 3

| Great job!

  |=================                                                                |  21%

| Next we'll do a boxplot. First, though, run the R command table with the argument
| airquality$Month.

> table(airquality$Month)

 5  6  7  8  9 
31 30 31 31 30 

| You are amazing!

  |==================                                                               |  23%

| We see that the data covers 5 months, May through September. We'll want a boxplot of
| ozone as a function of the month in which the measurements were taken so we'll use the R
| formula Ozone~Month as the first argument of boxplot. Our second argument will be
| airquality, the dataset from which the variables of the first argument are taken.  Try
| this now.

> boxplot(Ozone~Month, data=airquality)

| That's correct!

  |====================                                                             |  24%

| Note that boxplot, unlike hist, did NOT specify a title and axis labels for you
| automatically.

...

  |=====================                                                            |  26%

| Let's call boxplot again to specify labels. (Use the up arrow to recover the previous
| command and save yourself some typing.) We'll add more arguments to the call to specify
| labels for the 2 axes. Set xlab equal to "Month" and ylab equal to "Ozone (ppb)".
| Specify col.axis equal to "blue" and col.lab equal to "red". Try this now.

> play()

| Entering play mode. Experiment as you please, then type nxt() when you are ready to
| resume the lesson.

> dev.cur()
png 
  4 
> dev.off
function (which = dev.cur()) 
{
    if (which == 1) 
        stop("cannot shut down device 1 (the null device)")
    .External(C_devoff, as.integer(which))
    dev.cur()
}
<bytecode: 0x0000000003496ac0>
<environment: namespace:grDevices>
> dev.off()
null device 
          1 
> dev.cur()
null device 
          1 
> ?Devices
> windows()
> dev.set(2)
null device 
          1 
> dev.set(3)
png 
  3 
> dev.set(0)
RStudioGD 
        2 
> boxplot(Ozone~Month, data=airquality)
> nxt()

| Resuming lesson...


| Let's call boxplot again to specify labels. (Use the up arrow to recover the previous
| command and save yourself some typing.) We'll add more arguments to the call to specify
| labels for the 2 axes. Set xlab equal to "Month" and ylab equal to "Ozone (ppb)".
| Specify col.axis equal to "blue" and col.lab equal to "red". Try this now.

> boxplot(Ozone~Month, data=airquality, xlab="Month", ylab="Ozone (ppb)", col.axis="blue", col.lab="red")

| You're the best!

  |======================                                                           |  27%

| Nice colors, but still no title. Let's add one with the R command title. Use the
| argument main set equal to the string "Ozone and Wind in New York City".

> title("Ozone and Wind in New York City")

| You got it!

  |=======================                                                          |  29%

| Now we'll show you how to plot a simple two-dimensional scatterplot using the R function
| plot. We'll show the relationship between Wind (x-axis) and Ozone (y-axis). We'll use
| the function plot with those two arguments (Wind and Ozone, in that order). To save some
| typing, though, we'll call the R command with using 2 arguments. The first argument of
| with will be airquality, the dataset containing Wind and Ozone; the second argument will
| be the call to plot. Doing this allows us to avoid using the longer notation, e.g.,
| airquality$Wind. Try this now.

> with(airquality, plot(Wind, Ozone))

| You are amazing!

  |=========================                                                        |  30%

| Note that plot generated labels for the x and y axes but no title.

...

  |==========================                                                       |  32%

| Add one now with the R command title. Use the argument main set equal to the string
| "Ozone and Wind in New York City". (You can use the up arrow to recover the command if
| you don't want to type it.)

> with(airquality, plot(Wind, Ozone), main="Ozone and Wind in New York City")

| You almost had it, but not quite. Try again. Or, type info() for more options.

| Type title(main="Ozone and Wind in New York City") at the command prompt.

> title("Ozone and Wind in New York City")

| You are quite good my friend!

  |===========================                                                      |  33%

| The basic plotting parameters are documented in the R help page for the function par.
| You can use par to set parameters OR to find out what values are already set. To see
| just how much flexibility you have, run the R command length with the argument par()
| now.

> length(par())
[1] 72

| Keep working like that and you'll get there!

  |============================                                                     |  35%

| So there are a boatload (72) of parameters that par() gives you access to. Run the R
| function names with par() as its argument to see what these parameters are.

> names(par())
 [1] "xlog"      "ylog"      "adj"       "ann"       "ask"       "bg"        "bty"      
 [8] "cex"       "cex.axis"  "cex.lab"   "cex.main"  "cex.sub"   "cin"       "col"      
[15] "col.axis"  "col.lab"   "col.main"  "col.sub"   "cra"       "crt"       "csi"      
[22] "cxy"       "din"       "err"       "family"    "fg"        "fig"       "fin"      
[29] "font"      "font.axis" "font.lab"  "font.main" "font.sub"  "lab"       "las"      
[36] "lend"      "lheight"   "ljoin"     "lmitre"    "lty"       "lwd"       "mai"      
[43] "mar"       "mex"       "mfcol"     "mfg"       "mfrow"     "mgp"       "mkh"      
[50] "new"       "oma"       "omd"       "omi"       "page"      "pch"       "pin"      
[57] "plt"       "ps"        "pty"       "smo"       "srt"       "tck"       "tcl"      
[64] "usr"       "xaxp"      "xaxs"      "xaxt"      "xpd"       "yaxp"      "yaxs"     
[71] "yaxt"      "ylbias"   

| Great job!

  |=============================                                                    |  36%

| Variety is the spice of life. You might recognize some of these such as col and lwd from
| previous swirl lessons. You can always run ?par to see what they do. For now, run the
| command par()$pin and see what you get.

> par()$pin
[1] 7.697500 2.993333

| Excellent work!

  |===============================                                                  |  38%

| Alternatively, you could have gotten the same result by running par("pin") or
| par('pin')).  What do you think these two numbers represent?

1: Coordinates of the center of the plot window
2: Plot dimensions in inches
3: Random numbers
4: A confidence interval

Selection: 1

| You almost had it, but not quite. Try again.

| The function par specifies graphical parameters so the answer should deal with plots.
| That leaves two choices. The 'in' in 'pin' specifies inches.

1: Coordinates of the center of the plot window
2: Plot dimensions in inches
3: A confidence interval
4: Random numbers

Selection: 2

| You are amazing!

  |================================                                                 |  39%

| Now, run the command par("fg") or or par('fg') or par()$fg and see what you get.

> par()$fg
[1] "black"

| You are really on a roll!

  |=================================                                                |  41%

| It gave you a color, right? Since par()$fg specifies foreground color, what do you think
| par()$bg specifies?

1: Beautiful color
2: Better color
3: blue-green
4: Background color

Selection: 4

| You got it right!

  |==================================                                               |  42%

| Many base plotting functions share a set of parameters. We'll go through some of the
| more commonly used ones now. See if you can tell what they do from their names.

...

  |====================================                                             |  44%

| What do you think the graphical parameter pch controls?

1: pc help
2: point control height
3: plot character
4: picture characteristics

Selection: 3

| That's the answer I was looking for.

  |=====================================                                            |  45%

| The plot character default is the open circle, but it "can either be a single character
| or an integer code for one of a set of graphics symbols." Run the command par("pch") to
| see the integer value of the default. When you need to, you can use R's Documentation
| (?pch) to find what the other values mean.

> par("pch")
[1] 1

| You are doing so well!

  |======================================                                           |  47%

| So 1 is the code for the open circle. What do you think the graphical parameters lty and
| lwd control respectively?

1: line slope and intercept
2: line width and type
3: line length and width
4: line type and width

Selection: 4

| You are quite good my friend!

  |=======================================                                          |  48%

| Run the command par("lty") to see the default line type.

> par("lty")
[1] "solid"

| All that practice is paying off!

  |========================================                                         |  50%

| So the default line type is solid, but it can be dashed, dotted, etc. Once again, R's
| ?par documentation will tell you what other line types are available. The line width is
| a positive integer; the default value is 1.

...

  |==========================================                                       |  52%

| We've seen a lot of examples of col, the plotting color, specified as a number, string,
| or hex code; the colors() function gives you a vector of colors by name.

...

  |===========================================                                      |  53%

| What do you think the graphical parameters xlab and ylab control respectively?

1: labels for the y- and x- axes
2: labels for the x- and y- axes

Selection: 2

| All that practice is paying off!

  |============================================                                     |  55%

| The par() function is used to specify global graphics parameters that affect all plots
| in an R session. (Use dev.off or plot.new to reset to the defaults.) These parameters
| can be overridden when specified as arguments to specific plotting functions. These
| include las (the orientation of the axis labels on the plot), bg (background color), mar
| (margin size), oma (outer margin size), mfrow and mfcol (number of plots per row,
| column).

...

  |=============================================                                    |  56%

| The last two, mfrow and mfcol, both deal with multiple plots in that they specify the
| number of plots per row and column. The difference between them is the order in which
| they fill the plot matrix. The call mfrow will fill the rows first while mfcol fills the
| columns first.

...

  |===============================================                                  |  58%

| So to reiterate, first call a basic plotting routine. For instance, plot makes a
| scatterplot or other type of plot depending on the class of the object being plotted.

...

  |================================================                                 |  59%

| As we've seen, R provides several annotating functions. Which of the following is NOT
| one of them?

1: hist
2: title
3: points
4: text
5: lines

Selection: 1

| Great job!

  |=================================================                                |  61%

| So you can add text, title, points, and lines to an existing plot. To add lines, you
| give a vector of x values and a corresponding vector of y values (or a 2-column matrix);
| the function lines just connects the dots. The function text adds text labels to a plot
| using specified x, y coordinates.

...

  |==================================================                               |  62%

| The function title adds annotations. These include x- and y- axis labels, title,
| subtitle, and outer margin. Two other annotating functions are mtext which adds
| arbitrary text to either the outer or inner margins of the plot and axis which adds axis
| ticks and labels. Another useful function is legend which explains to the reader what
| the symbols your plot uses mean.

...

  |====================================================                             |  64%

| Before we close, let's test your ability to make a somewhat complicated scatterplot.
| First run plot with 3 arguments. airquality$Wind, airquality$Ozone, and type set equal
| to "n". This tells R to set up the plot but not to put the data in it.

> plot(airquality$Wind, airquality$Ozone, type="n")

| You are quite good my friend!

  |=====================================================                            |  65%

| Now for the test. (You might need to check R's documentation for some of these.) Add a
| title with the argument main set equal to the string "Wind and Ozone in NYC"

> title(main="Wind and Ozone in NYC")

| You nailed it! Good job!

  |======================================================                           |  67%

| Now create a variable called may by subsetting airquality appropriately. (Recall that
| the data specifies months by number and May is the fifth month of the year.)

> may <- airquality[Month == 5]
Error in `[.data.frame`(airquality, Month == 5) : 
  object 'Month' not found
> may <- airquality[airquality$Month == 5]
Error in `[.data.frame`(airquality, airquality$Month == 5) : 
  undefined columns selected
> may <- subset( airquality, Month == 5)

| You are quite good my friend!

  |=======================================================                          |  68%

| Now use the R command points to plot May's wind and ozone (in that order) as solid blue
| triangles. You have to set the color and plot character with two separate arguments.
| Note we use points because we're adding to an existing plot.

> play()

| Entering play mode. Experiment as you please, then type nxt() when you are ready to
| resume the lesson.

> ?par
> nxt()

| Resuming lesson...


| Now use the R command points to plot May's wind and ozone (in that order) as solid blue
| triangles. You have to set the color and plot character with two separate arguments.
| Note we use points because we're adding to an existing plot.

> points(may$Wind, may$Ozone, col="blue", pch=17)

| Excellent job!

  |========================================================                         |  70%

| Now create the variable notmay by subsetting airquality appropriately.

> notmay <- subset( airquality, Month != 5)

| Nice work!

  |==========================================================                       |  71%

| Now use the R command points to plot these notmay's wind and ozone (in that order) as
| red snowflakes.

> points(notmay$Wind, notmay$Ozone, col="red", pch=8)

| That's the answer I was looking for.

  |===========================================================                      |  73%

| Now we'll use the R command legend to clarify the plot and explain what it means. The
| function has a lot of arguments, but we'll only use 4. The first will be the string
| "topright" to tell R where to put the legend. The remaining 3 arguments will each be
| 2-long vectors created by R's concatenate function, e.g., c(). These arguments are pch,
| col, and legend. The first is the vector (17,8), the second ("blue","red"), and the
| third ("May","Other Months"). Try it now.

> legend("topright", pch=c(17,8), col=c("blue","red", legend=c("May","Other Months"))
+ )
Error in as.graphicsAnnot(legend) : 
  argument "legend" is missing, with no default
> legend("topright", pch=c(17,8), col=c("blue","red"), legend=c("May","Other Months"))

| That's correct!

  |============================================================                     |  74%

| Now add a vertical line at the median of airquality$Wind. Make it dashed (lty=2) with a
| width of 2.

> abline(v=median(airquality$Wind), lty=2, lwd=2)

| You got it right!

  |=============================================================                    |  76%

| Use par with the parameter mfrow set equal to the vector (1,2) to set up the plot window
| for two plots side by side. You won't see a result.

> mfrow(c(1,2))
Error: could not find function "mfrow"
> par(mfrow=c(1,2))

| Perseverance, that's the answer.

  |===============================================================                  |  77%

| Now plot airquality$Wind and airquality$Ozone and use main to specify the title "Ozone
| and Wind".

> plot(airquality$Wind, airquality$Ozone, main="Ozone and Wind")

| You got it!

  |================================================================                 |  79%

| Now for the second plot.

...

  |=================================================================                |  80%

| Plot airquality$Ozone and airquality$Solar.R and use main to specify the title "Ozone
| and Solar Radiation".

> plot(airquality$Ozone,airquality$Solar.R,  main="Ozone and Solar Radiation")

| All that practice is paying off!

  |==================================================================               |  82%

| Now for something more challenging.

...

  |====================================================================             |  83%

| This one with 3 plots, to illustrate inner and outer margins. First, set up the plot
| window by typing par(mfrow = c(1, 3), mar = c(4, 4, 2, 1), oma = c(0, 0, 2, 0))

> par(mfrow = c(1, 3), mar = c(4, 4, 2, 1), oma = c(0, 0, 2, 0))

| That's correct!

  |=====================================================================            |  85%

| Margins are specified as 4-long vectors of integers. Each number tells how many lines of
| text to leave at each side. The numbers are assigned clockwise starting at the bottom.
| The default for the inner margin is c(5.1, 4.1, 4.1, 2.1) so you can see we reduced each
| of these so we'll have room for some outer text.

...

  |======================================================================           |  86%

| The first plot should be familiar. Plot airquality$Wind and airquality$Ozone with the
| title (argument main) as "Ozone and Wind".

> plot(airquality$Wind, airquality$Ozone, main="Ozone and Wind")

| Excellent job!

  |=======================================================================          |  88%

| The second plot is similar.

...

  |========================================================================         |  89%

| Plot airquality$Solar.R and airquality$Ozone with the title (argument main) as "Ozone
| and Solar Radiation".

> plot(airquality$Ozone,airquality$Solar.R,  main="Ozone and Solar Radiation")

| Almost! Try again. Or, type info() for more options.

| Type plot(airquality$Solar.R, airquality$Ozone, main = "Ozone and Solar Radiation").

> plot(airquality$Solar.R, airquality$Ozone, main = "Ozone and Solar Radiation")

| All that practice is paying off!

  |==========================================================================       |  91%

| Now for the final panel.

...

  |===========================================================================      |  92%

| Plot airquality$Temp and airquality$Ozone with the title (argument main) as "Ozone and
| Temperature".

> plot(airquality$Temp, airquality$Ozone, main = "Ozone and Temperature")

| Keep working like that and you'll get there!

  |============================================================================     |  94%

| Now we'll put in a title.

...

  |=============================================================================    |  95%

| Since this is the main title, we specify it with the R command mtext. Call mtext with
| the string "Ozone and Weather in New York City" and the argument outer set equal to
| TRUE.

> mtext("Ozone and Weather in New York City", outer=TRUE)

| Keep up the great work!

  |===============================================================================  |  97%

| Voila! Beautiful, right?

...

  |================================================================================ |  98%

| Congrats! You've weathered this lesson nicely and passed out of the No!zone.

...

  |=================================================================================| 100%
  
  

